<!doctype html>

<html lang="de">

<head> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <!-- Einbinden des CSS-Stylsheets -->
</head>


<body>
    <!--  <canvas width="500" height="500" id="myCanvas" style="background-color: lightgrey ;position:absolute"></canvas> -->
    <!-- ApiInformationen / LÖSCHEN VOR ABGABE -->
    <div id="sinfo"> 
        <p id="sid">test</p>
        <p id="sname">test</p>
        <p id="spath">test</p>
    </div>
    <p id="response">response</p>


    <script>
    /*
    function extract(result) {
        var result = JSON.parse(result);
        for (let i = 0; i < result.length; i ++) {
            var tem_arr = result[i];
            for(var j = 0;j < tem_arr.length;j++){
                console.log(tem_arr[j]);
                alert(tem_arr[j]);
                }  
        };
    }
    function getapi() {
        fetch("https://343505-26.web.fhgr.ch/api/covid/games/", {method:'GET'}).then(response => response.text()).then(result => {extract(result)}).catch(error => console.log('error', error));};
    getapi()
    */
    /* var test_data = [
        ["vlue1", 18, "ram", "xmy"],
        ["value2", 21, "abc", "xyz"]
    ];
    for(var i = 0;i < data.length;i++){
        var tem_arr = data[i];
        for(var j = 0;j < tem_arr.length;j++){
            console.log(tem_arr[j]);
        }
    } */



    function appendData (data) {
    console.log (data);
    document.querySelector ("div").innerHTML = JSON.stringify(data);
    }
    fetch ("https://343505-26.web.fhgr.ch/api/covid/games/",{method:'GET'}).then (function (response) {
    return response.json();
    }).then (function (data) {
    appendData (data[1]["trackrecord"]);
    }).catch (function (error) {
    console.log ("error: " + error);
    });






    /*var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    // Circle und Line habe ich hier in meinem Beispielfile definiert und Benutzt 

    function circle(a,b){
        ctx.beginPath();
        ctx.arc(a,b, 3, 0, Math.PI*2);
        ctx.stroke();
    }

    function line(a,b,c,d) {
        ctx.beginPath();
        ctx.moveTo(a,b);
        ctx.lineTo(c,d);
        ctx.stroke();
    } 

    // Drawdown bewegt die Spielfigur auf die korrekte vertikale höhe und löst drawside aus

    function drawdown(a1,a2,b1,b2,i){
        var a = a1; b = a2; c = a1; d = b2;            // Zuweisung Start und Endpunkte
        var disbd = d-b;                               // Abstände zwischen den Punkten
        var j = disbd*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
        var  movebd = disbd / j;                       //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
        circle(a,b);
        if (i == j) {drawside(a1,a2,b1,b2,0)}
        else {var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a,b+(movebd*i)),              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (movebd+j) verlängert
                drawdown(a1,a2,b1,b2,i,j)              //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
            }, 10);}
    }

    function drawside(a1,a2,b1,b2,i){
        var a = a1; b = b2; c = b1; d = b2;            // Zuweisung Start und Endpunkte
        var disac = Math.sqrt((c-a)**2);               // Abstände zwischen den Punkten, zuerst quadriert + dann wurzel damit wert positiv
        var j = disac*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
        var moveac = disac / j;                        //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
        if (a > c) {                                   // a grösser als c: nach links gehen
            if (i == j) {circle(c,d)}
            else {
                var i = i + 1;
                const myTimeout = setTimeout(function() {
                    line(a,b,a-(moveac*i),b),              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (moveac+j) verlängert
                    drawside(a1,a2,b1,b2,i,j)              //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
                }, 10);}
        }
        else if (c > a) {                                 // c grösser als a: nach rechts gehen
            if (i == j) {circle(c,d)}
            else {
                var i = i + 1;
                const myTimeout = setTimeout(function() {
                    line(a,b,a+(moveac*i),b),
                    drawside(a1,a2,b1,b2,i,j)
                }, 10);}
        };
    }

    // Loadlines liest die bisherigen Punkte als Array ein und generiert eine Line die alle passierten Punkte auf einmal einblendet

    function loadlines(knots){
        for (let i = 0; i < knots.length; i++) {
            var a1 = knots[i]["a"]; a2 = knots[i]["b"]; b1 = knots[i+1]["a"]; b2 = knots[i+1]["b"];
            var a = a1; b = a2; c = a1; d = b2;        //start-/endpunkte vertikale linie
            circle(a,b);
            line(a,b,c,d);                             //vertikale linie
            var a = a1; b = b2; c = b1; d = b2;        //start-/endpunkte horizontale linie
            line(a,b,c,d);                             // horizontale linie
        }
    }

    // Path ist jetzt hier ein Beispielweg mit drei passierten Punkten

    const path = [
    {a:0,b:0}, 
        {a:150,b:100}, 
        {a:50,b:150}, 
        {a:200,b:300},
        {a:350,b:450} 
    ]

    //So habe ich die Funktionen getestet. Komischerweise funktioniert es aktuell nur wenn zuerst drawdown ausgeführt wird, 
    //warum weiss ich nicht (Spielt von der funktionalität her aber keine rolle aktuell)

    drawdown(350,450,500,500,0);
    loadlines(path);

    */

    </script>

</body>