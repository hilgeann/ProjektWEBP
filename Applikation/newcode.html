<!doctype html>
<html lang="de">
<head> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css"> <!-- Einbinden des CSS-Stylsheets -->
</head>
<body>
    <div id="welcome"> 
        <h1>Willkommen bei der interaktiven Bestimmung deines Pandemietyps</h1>
        <p>Gib bitte zuerst bitte deinen Namen ein!</p>
        <input type="text" id="entername">
        <button onclick="validate()">Start</button>
    </div>
    <div id="game"> 
        <div class ="togglebox">
            <label class="toggle">
                <input id="toggleswitch" type="checkbox">
                <span class="roundbutton"></span>
            </label>
            <label class="toggletext">Wähle deine Spielfigur!</label class="toggletext">
        </div class ="togglebox">    

        <div class="anim">
            <canvas width="400" height="400" id="back" style="background-color: #FFF0B5 ;position:absolute"></canvas>
            <canvas width="400" height="400" id="front" style="position:absolute"></canvas>
        </div class="anim">

        
        <!-- Einblenden der möglichen Antwort-Buttons je nach Anzahl -->
        <div id="options"> 
            <h1 id="question"> </h1>
            <p id=linea> <button> <opt id=opta> </opt> </button> </p> 
            <p id=lineb> <button> <opt id=optb> </opt> </button> </p> 
            <p id=linec> <button> <opt id=optc> </opt> </button> </p> 
            <p id=lined> <button> <opt id=optd> </opt> </button> </p> 
        </div>
    </div>
    <div id="result"> 
        <h1>Dein Resultat</h1>
        <label class=r1> <p id=resa>  </p> </label>
        <label class=r1> <p id=resb>  </p> </label>
        <label class=r1> <p id=resc>  </p> </label>
        <label class=r1> <p id=resd>  </p> </label>
    </div>   
    <div id="stats"> 
        <h1>Willkommen bei den Umfragestatistiken</h1>
        <p>...</p>
        <button onclick="">New Game</button>
    </div>   
    <table>
        <tr>
            <td>UserID:</td>
            <td id="userid">
                Unbekannt
            </td>
        </tr>
        <tr>
          <td>UserName</td>
            <td id="username">
                Unbekannt
            </td>
         </tr>
         <tr>
           <td>Trackrecord:</td>
            <td id="trec">
                Unbekannt
            </td>
         </tr>
      </table>
</body>

<script>

// Array mit den Ergebnissen bzw. Pandemietypen.
const results = {
a: "Vorsichtige",
b: "Wellensurfer",
c: "Wiederwillige",
d: "Superspreader",
e: "Uninformierte",
f: "Kritikerin",
g: "Naturheilpraktikerin"
}

// Array mit den Beschreibungen der Pandemietypen.
const resultstring = {
    a: "Wow! Du nimmst es genau. <br> Du bist der Typ, der immer Vorsicht walten lässt und das Wohl anderer über das Eigene stellt. <br> Super!",
    b: "Hut ab. <br> Obwohl du dir ein wenig Freiheiten gönnst und dein Leben möglichst normal weiter lebst, bist du vorsichtig, wenn es darauf ankommt. <br> Gut!",
    c: "Du trägst die Massnahmen zwar mehrheitlich mit, obwohl du keine Lust mehr hast. <br> Motivier dich noch ein wenig, denn wir sind im Endspurt.",
    d: "Vorsichtig ist anders, du kooperierst leider nicht. <br> Bitte halte dich an die geltenden Massnahmen, es zu deinem Wohl und zum Schutz deiner Mitmenschen!",
    e: "Du hast wohl nicht viel mitbekommen. <br> Informiere dich doch unter www.bag.admin.ch über die aktuelle Situation.",
    f: "Ups! Leider lebst du in einer anderen Realität, als die Mehrheit der Bevölkerung. <br> Wir empfehlen dir eine Social-Media-Diät.",
    g: "Wir stellen fest, dass du die Massnahmen missachtest und eine Grundabneigung gegen Wissenschaft sowie Schulmedizin hast. <br> Bitte informiere dich künftig nur bei offiziellen Stellen und überdenke deine Überzeugungen."
}

const knots = ["", 
"Corona-Pandemie ist...",
"Corona ist ja eine kleine Grippe..",
"Hattest du Corona?",
"Bist du dennoch geimpft?",
"Bist du geimpft?",
"Bist du geimpft?",
"Ach, wen kümmert die Pandemie will einfach nach Mallorca",
"Trägst du Maske?",
"Impfungen sind...",
"Distance Learning ist...",
"dieses Wochenende...",
"Weisst du um welche Impfungen es überhaupt geht?",
"Mein Immunsystem ist sowieso besser als jede Impfung"
]

// Array mit den möglichen Antworten pro Frage
const options = [{a:""},
{a:"Coro-was?", b:"Reine Panikmache!", c:"eine Viruspandemie"},
{a:"Nein, bestimmt nicht!", b:"Ja, definitiv."},
{a:"Weiss nicht, diese Tests sind ohnehin manipuliert!", b:"Ja, was solls?", c:"Ja, leider...", d:"Nein."},
{a:"Ja", b:"Nein"},
{a:"Ja", b:"Nein"},
{a:"Ja", b:"Nein"},
{a:"Die Pandemie muss Enden, mit oder ohne Ferien", b:"Genau, wo sind meine Flipflops?"},
{a:"Wozu?", b:"Ja, klar!"},
{a:"Von Reptioloiden eingeführt um Menschen zu unterwerfen", b:"Gift", c:"hä? worum gehts?"},
{a:"Ein riesen Quatsch!", b:"Eine Super Sache!"},
{a:"muss ich an eien Party", b:"bleibe ich daheim (wie immer)"},
{a:"Nein", b:"Ja, aber...."},
{a:"Ja", b:"Weiss auch nicht"},
]

// Array gibt an, wie viele Antwortmöglichkeiten pro Frage zur Auswahl stehen.
const optnum = [0,3,2,4,2,2,2,2,2,3,2,2,2,2]

// Array gibt an, welche Antwort aus "options" zu welcher Frage "knots" bzw. am Ende zu welchem Ergebnis "result" führt.
const redirection = [{a:""},
{a:25, b:2, c:3},
{a:3, b:5},
{a:5, b:7, c:4, d:6},
{a:8, b:7},
{a:7, b:9},
{a:8, b:7},
{a:23, b:13},
{a:7, b:10},
{a:26, b:27, c:12},
{a:22, b:11},
{a:22, b:21},
{a:25, b:13},
{a:24, b:25},
]

const size = 50;
const corra = size*0.8; 
const corrb = size*0.2;

function clear(layer) {
    var canvas = document.getElementById(layer)
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,400,400);
    }
}

function vac(a,b) {
    var a = a - corra;
    var b = b - corrb;
    clear("front")
    var checkBox = document.getElementById("toggleswitch"); // ermöglicht das Wechseln der Spilefigur auch während der Pfad gezeichnet wird.
    if (checkBox.checked == true) {
        x = size*0.3;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            
            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+1.5*x,b+0.1*x)
            ctx.quadraticCurveTo(a+0.2*x, b+0.3*x, a+1.5*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+4*x,b+0.1*x)
            ctx.quadraticCurveTo(a+5.3*x, b+0.3*x, a+4*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.rect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            ctx.stroke();

            ax = a+1.7*x;
            bx = b+0.35*x;
            for (let i = 0; i < 3; i++) {
                shadow = 0.1*x
                ctx.beginPath();
                ctx.lineWidth = shadow;
                ctx.strokeStyle = "#DCdCdC";
                ctx.moveTo(ax, bx+shadow);
                ctx.lineTo(ax+2*x, bx+shadow);
                ctx.stroke();

                ctx.beginPath();
                ctx.lineWidth = 0.1*x;
                ctx.strokeStyle = "black";
                ctx.moveTo(ax, bx);
                ctx.lineTo(ax+2*x, bx);
                ctx.stroke();
                bx = bx + 0.4*x;
            }
        }
    } 
    else {
        x = size*0.25;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.fillRect(a+0, b+0.6*x, 1*x, 0.25*x);
            
            ax = a+2*x;
            bx = b+0;
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.lineWidth = x/20;
                ctx.strokeStyle = "black";

                ctx.moveTo(ax, bx);
                ctx.lineTo(ax, bx+0.8*x);
                ctx.stroke();
                ax = ax + 0.4*x;
            }
            
            ctx.beginPath();
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(a+1*x, b+0, 1*x, 1.5*x)

            ctx.beginPath();
            ctx.lineWidth = x/8;
            ctx.strokeStyle = "black";
            ctx.rect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.6*x, 1*x, 0.25*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.47*x, 0.05*x, 0.5*x);
            ctx.stroke();
            ctx.rect(a+5*x, b+0.7*x, 1.2*x, 0.01*x);
            ctx.stroke();
         } 
    }
}

const coordinates = [
    {a:2, b:1},
    {a:3, b:1},
    {a:6, b:2},
    {a:2, b:2},
    {a:4, b:2.5},
    {a:7, b:3},
    {a:1, b:3},
    {a:4, b:4.5},
    {a:1.5, b:4},
    {a:6.5, b:4},
    {a:2, b:5},
    {a:2.5, b:6},
    {a:6, b:5},
    {a:5.5, b:6},
    {a:0, b:1}, //Startpunkt hinzugefügt
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:2, b:7.5},
    {a:1, b:7.5},
    {a:3, b:7.5},
    {a:4, b:7.5},
    {a:5, b:7.5},
    {a:6, b:7.5},
    {a:7, b:7.5}
]

const linecolour = "grey";
const linewidth = 7;

function dot(a,b,dotsize,colour) {
    var canvas = document.getElementById("back");
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(a, b, dotsize, 0, Math.PI*2);
        ctx.fillStyle = colour;
        ctx.fill();
        ctx.closePath();
    }
}

function line(a,b,c,d) {
    var canvas = document.getElementById("back");
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');   
        dot(a,b,linewidth*0.5,linecolour);
        ctx.beginPath();
        ctx.moveTo(a,b);
        ctx.stroke();
        ctx.lineTo(c,d);
        ctx.lineWidth = linewidth;
        ctx.strokeStyle = linecolour;
        ctx.stroke();
        dot(a,b,linewidth*0.4,linecolour);
    }
} 

function maindots(a,b,type) {             //type 1: durchquerte dots; type 2: offene dots; type 3: zieldots
    if (type == 1) {dot(a,b,20,"#d0bdfb"); dot(a,b,10,"#808080")}
    else if (type == 2) { dot(a,b,20,"#d7966d"); dot(a,b,10,"#598ebb") }
    else if (type == 3) { dot(a,b,20,"#598ebb"); dot(a,b,10,"#d7966d") }
}


// Drawdown bewegt die Spielfigur auf die korrekte vertikale höhe und löst drawside aus

function drawdown(p1,p2,i,j){
    let c = coordinates; let s = size;
    var a1 = (c[p1].a)*s; a2 = (c[p1].b)*s; b1 = (c[p2].a)*s; b2 = (c[p2].b)*s;
    var a = a1; b = a2; c = a1; d = b2;            // Zuweisung Start und Endpunkte
    var disbd = d-b;                               // Abstände zwischen den Punkten
    var j = disbd*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var  movebd = disbd / j;                       //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    if (i == j) {drawside(p1,p2,0)}
    else {
        var i = i + 1;
        const myTimeout = setTimeout(function() {
            line(a,b,a,b+(movebd*i));              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (movebd+j) verlängert
            vac(a,b+(movebd*i));
            drawdown(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
        }, 10);}
}


function drawside(p1,p2,i,j){
    let c = coordinates; let s = size;
    var a1 = (c[p1].a)*s; a2 = (c[p1].b)*s; b1 = (c[p2].a)*s; b2 = (c[p2].b)*s;    var a = a1; b = b2; c = b1; d = b2;            // Zuweisung Start und Endpunkte
    var disac = Math.sqrt((c-a)**2);               // Abstände zwischen den Punkten, zuerst quadriert + dann wurzel damit wert positiv
    var j = disac*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var moveac = disac / j;                        //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    if (a > c) {                                   // a grösser als c: nach links gehen
        if (i == j) { 
            dot(a1,a2,10,linecolour); {onspot = setInterval(function () {vac(b1,b2)}, 100)}}  //onspot interval aktualisiert die spielfigur im stillstand
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a-(moveac*i),b);
                vac(a-(moveac*i),b);              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (moveac+j) verlängert
                drawside(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
            }, 10);}
    }
    else if (c > a) {                                 // c grösser als a: nach rechts gehen
        if (i == j) {dot(a1,a2,10,linecolour); {onspot = setInterval(function () {vac(b1,b2)}, 100)}}  //onspot interval aktualisiert die spielfigur im stillstand
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a+(moveac*i),b),
                vac(a+(moveac*i),b);
                drawside(p1,p2,i,j)
            }, 10);}
    }
}

function dots() {  
    let c = coordinates; let s = size;let a = (c[0].a)*s;let b = (c[0].b)*s; maindots(a,b,1);
    for (let i = 1; i < 14; i++) {
        let c = coordinates; let s = size;
        let a = (c[i].a)*s;let b = (c[i].b)*s;
        maindots(a,b,2);
    }
    for (let i = 21; i < 28; i++) {
        let c = coordinates; let s = size;
        let a = (c[i].a)*s;let b = (c[i].b)*s;
        maindots(a,b,3);
    }
}

// Loadlines liest die bisherigen Punkte als Array ein und generiert eine Line die alle passierten Punkte auf einmal einblendet

function loadlines(knots){
    var start = [0];
    var knots = start.concat(knots);
    for (let i = 0; i < (knots.length)-2; i++) {
        let c = coordinates; let k = knots; let s = size; 
        var a1 = (c[k[i]].a)*s; a2 = (c[k[i]].b)*s; b1 = (c[k[i+1]].a)*s; b2 = (c[k[i+1]].b)*s;
        var a = a1; b = a2; c = a1; d = b2;        //start-/endpunkte vertikale linie
        line(a,b,c,d);                             //vertikale linie
        var a = a1; b = b2; c = b1; d = b2;        //start-/endpunkte horizontale linie
        line(a,b,c,d);
        maindots(c,d,1);
    }

}

//So habe ich die Funktionen getestet. Komischerweise funktioniert es aktuell nur wenn zuerst drawdown ausgeführt wird, 
//warum weiss ich nicht (Spielt von der funktionalität her aber keine rolle aktuell)

function fade(stringid, stringtext, type) {
    if (type == "in") {
        document.getElementById(stringid).style.opacity = 0; 
	/*
	getElementById als Methode des document-Objekts, um auf den jeweiligen Elementknoten zu zugreifen,
	der ein eindeutiges id-Atrribut erhält. Hier wird der Schrift die Deckkraft Null vergeben, da sie zu Beginn unsichtbar ist. 
	*/
        document.getElementById(stringid).innerHTML = stringtext;
	/* Durch inner.HTML wird der Inhalt für das jeweiligen HTML-Element gelesen und gespeichert.
	*/
        var value1 = 0.1
        const fader1 = setInterval(function() {
            document.getElementById(stringid).style.opacity = value1; //wiederholt die Vergabe des neuen Opacity-Werts alle 100mS
            value1 = value1 + 0.1
            }, 100)
            setTimeout(function(){clearInterval(fader1)},1100) //bricht das obige Interval nach 1100mS ab
        }
    else if (type == "out") {
        document.getElementById(stringid).style.opacity = 1;
        var value2 = 1
        const fader2 = setInterval(function() {
            document.getElementById(stringid).style.opacity = value2;
            value2 = value2 - 0.1
            }, 100)
            setTimeout(function(){clearInterval(fader2)},1100)
            setTimeout(function(){document.getElementById(stringid).innerHTML = ""},1100)
    }
}

function reload() {
    document.getElementById("linec").style.display = "initial";
    document.getElementById("lined").style.display = "initial";
}

function loadresult(i) {
    let rs = resultstring; let re = results; 
    if (i == 21) {var type = re.a; var text = rs.a}
    else if (i == 22) {var type = re.b; var text = rs.b}
    else if (i == 23) {var type = re.c; var text = rs.c}
    else if (i == 24) {var type = re.d; var text = rs.d}
    else if (i == 25) {var type = re.e; var text = rs.e}
    else if (i == 26) {var type = re.f; var text = rs.f}
    else if (i == 27) {var type = re.g; var text = rs.g};
    document.getElementById("options").style.display = "none";
    loadsite("result")
    fade("resa", "Dein Typ ist:", "in");
    fade("resb", type, "in");
    fade("resc", text, "in");
    fade("resd", "<button id=restart> Neues Spiel starten! </button>" , "in");
    document.getElementById("restart").addEventListener("click", function() {
        document.getElementById("options").style.display = "initial";
        restart()
    },); // der Button für den Neustart wird eingeblendet
}

function restart() {
    localStorage.removeItem("gamesid");
    clear("front"), clear("back");
    clearInterval(onspot);
    loadsite("welcome");
    checkGame()
}

function choice(i,x) {
    clearInterval(onspot);
    if (x == 1) {
        var j = redirection[i].a}
    else if (x == 2) {
        var j = redirection[i].b}
    else if (x == 3) {
        var j = redirection[i].c}
    else if (x == 4) {
        var j = redirection[i].d}
    currentgame["trackrecord"].push(j);
    update_trackrecord(currentgame);
    initialise();
};
    
function loadquestion(i) {
    reload(); // nach dem Klick auf eine Antwort, werden diese mit der Funktion reload wieder ausgeblendet, bis die neuen geladen wurden
    if (i > 20) {loadresult(i)}
    else {
        let k = optnum[i]
        var queststring = knots[i];
        fade("question", queststring, "in"); // FadeIn der neuen Frage
        var elema = document.getElementById("opta");
        var elemb = document.getElementById("optb");
        var elemc = document.getElementById("optc");
        var elemd = document.getElementById("optd");
        if (k == 2) {
        elema.innerHTML = options[i].a;
            elema.replaceWith(elema.cloneNode(true));
            document.getElementById("opta").addEventListener("click", function() {choice(i,1)},);
            elemb.innerHTML = options[i].b;
            elemb.replaceWith(elemb.cloneNode(true));
            document.getElementById("optb").addEventListener("click", function() {choice(i,2)},);
            document.getElementById("linec").style.display = "none";
            document.getElementById("lined").style.display = "none";}
        else if (k == 3) {
            elema.innerHTML = options[i].a;
            elema.replaceWith(elema.cloneNode(true));
            document.getElementById("opta").addEventListener("click", function() {choice(i,1)},);
            elemb.innerHTML = options[i].b;
            elemb.replaceWith(elemb.cloneNode(true));
            document.getElementById("optb").addEventListener("click", function() {choice(i,2)},);
            elemc.innerHTML = options[i].c;
            elemc.replaceWith(elemc.cloneNode(true));
            document.getElementById("optc").addEventListener("click", function() {choice(i,3)},);
            document.getElementById("lined").style.display = "none";}
        else if (k == 4) {
            elema.innerHTML = options[i].a;
            elema.replaceWith(elema.cloneNode(true));
            document.getElementById("opta").addEventListener("click", function() {choice(i,1)},);
            elemb.innerHTML = options[i].b;
            elemb.replaceWith(elemb.cloneNode(true));
            document.getElementById("optb").addEventListener("click", function() {choice(i,2)},);
            elemc.innerHTML = options[i].c;
            elemc.replaceWith(elemc.cloneNode(true));
            document.getElementById("optc").addEventListener("click", function() {choice(i,3)},);
            elemd.innerHTML = options[i].d;
            elemd.replaceWith(elemd.cloneNode(true));
            document.getElementById("optd").addEventListener("click", function() {choice(i,4)},);}
    }
}

function initialise() {
    dots();
    var path = currentgame["trackrecord"];
    var count = (path.length); 
    if (count == 1) {
        drawdown(0,1,0,0); 
        loadquestion(1)
    }
    else {
        var start = path[count-2]; var end = path[count-1];
        loadlines(path); 
        loadquestion(end);
        drawdown(start,end,0,0);
    }
    document.getElementById("userid").innerHTML = currentgame["gamesid"];
    document.getElementById("username").innerHTML = currentgame["username"];
    document.getElementById("trec").innerHTML = currentgame["trackrecord"];
}

//Testlauf:
//Beim Laden des Fensters wird User aufgefordert Name einzugeben
//Danach wird der User erstellt und die ersta Frage geladen

const currentgame =  {"username":"","gamesid":"","trackrecord":""}

function new_game (data) {
    fetch ("https://343505-26.web.fhgr.ch/api/covid/games" ,
        {method:'POST',
        headers: {
            'Content-Type': 'application/json'
        }, 
        body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
        console.log ('Success:', data);
        })
        .catch (error => {
        console.log ("error: " + error);
        });
}

function update_trackrecord (data) {
    var link = "https://343505-26.web.fhgr.ch/api/covid/games/";
    var serverlink = link.concat(data["gamesid"].toString());
    fetch (serverlink,
        {method:'PUT',
        headers: {
        'Content-Type': 'application/json'
        }, 
        body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
        console.log ('Success:', data);
        })
        .catch (error => {
        console.log ("error: " + error);
        });
}

function validate() {
    let name = document.getElementById("entername").value;
    if (name == "") {alert("Bitte Namen eingeben!")}
    else {getCount()}
}

function checkGame() {
    var status = localStorage.getItem("gamesid");
    if (status == null) {loadsite("welcome")}
    else {loadsite("game");getTrackrecord(status)}
}

function getCount() {
    fetch ("https://343505-26.web.fhgr.ch/api/covid/games/scount", {method:'GET', headers: {'Content-Type': 'application/json'}})
    .then(response => response.json())
    .then(result => {createGame(result["trackrecord"])})
    .catch (error => {console.log ("error: " + error);})
}

function getTrackrecord(gameid) {
    var link = "https://343505-26.web.fhgr.ch/api/covid/games/";
    var serverlink = link.concat(gameid.toString());
    fetch (serverlink, {method:'GET', headers: {'Content-Type': 'application/json'}})
    .then(response => response.json())
    .then(result => {reloadGame(result)})
    .catch (error => {console.log ("error: " + error);})
}

function loadsite(site) {
    if (site == "welcome") {
        document.getElementById("game").style.display = "none";
        document.getElementById("welcome").style.display = "initial";
        document.getElementById("stats").style.display = "none";
        document.getElementById("result").style.display = "none";
    }
    else if (site == "game") {
        document.getElementById("game").style.display = "initial";
        document.getElementById("welcome").style.display = "none";
        document.getElementById("stats").style.display = "none";
        document.getElementById("result").style.display = "none";
    }
    else if (site == "stats") {
        document.getElementById("game").style.display = "none";
        document.getElementById("welcome").style.display = "none";
        document.getElementById("stats").style.display = "initial";
        document.getElementById("result").style.display = "none";
    }
    else if (site == "result") {
        document.getElementById("game").style.display = "initial";
        document.getElementById("welcome").style.display = "none";
        document.getElementById("stats").style.display = "none";
        document.getElementById("result").style.display = "initial";
    }
}

function createGame(count) {
    let currid = parseInt(count)+1;
    let name = document.getElementById("entername").value;
    let data = {"gamesid":currid, "username":name, "trackrecord":[1]};
    currentgame["gamesid"] = currid; currentgame["trackrecord"] = [1]; currentgame["username"] = name;
    var cdata = {"username":"gcount","gamesid":"scount","trackrecord":currid};
    //localStorage.setItem("gamesid", currid);
    loadsite("game");
    initialise();
    new_game(data);update_trackrecord(cdata);
}

function reloadGame(result) {
    currentgame["gamesid"] = result["gamesid"]; 
    currentgame["trackrecord"] = result["trackrecord"]; 
    currentgame["username"] = result["username"];
    initialise()
}

checkGame()

/*

Code Ergänzungen:
- Reload Funktion geht noch nicht
- Willkommensseite mit schönem Feld zur Namenseingabe
- Für laufende Spiele "Abbruch"-Button? 
- Für abgeschlossene Spiele: Zurückkehrende User die abgeschlossen haben Fragen, ob sie nochmal machen wollen.

Visualisierung + Statistik:
- Visiualisierung wie? evtl. D3?
- Statistik überarbeiten? 
- Swagger: Statistik POST-Befehl (statistik) / Patch-Befehl (Games/statistik)

Statistik Neuer Aufbau
{
"statid": 1, #int / required
"statname": "Wellensurfer", #str / required
"statndesc": "Wellensurfer", #str / notrequired
"maincount": 2, #int / required
"att1": 0, #int / notrequired
"att2": 0, #int / notrequired
"att3": 0, #int / notrequired
"att4": 0, #int / notrequired
"att5": 0 #int / notrequired
}

Strings: post/get/put
strings/results {resultid: int, resultname: "str"; resulttext: "str"} 
string/fragen {frageid: int, fragetest: str, optnum: int, opttexts, redirection: array (key+value oder liste)}

*/

</script>

