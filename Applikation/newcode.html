<!doctype html>
<html lang="de">
<head> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <!-- Einbinden des CSS-Stylsheets -->
</head>
<body>
    <div class ="togglebox">
        <label class="toggle">
            <input id="toggleswitch" type="checkbox">
            <span class="roundbutton"></span>
         </label>
        <label class="toggletext">Wähle deine Spielfigur!</label class="toggletext">
    </div class ="togglebox">    
    
    <canvas width="400" height="400" id="myCanvas" style="background-color: lightblue ;position:absolute"></canvas>
    <canvas width="400" height="400" id="front" style="position:absolute"></canvas>
</body>

<script>

const size = 50;
const corra = size*0.8; 
const corrb = size*0.2;

function clear(layer) {
    var canvas = document.getElementById(layer)
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,400,400);
        }
}

function vac(a,b) {
    clear("front")
    var checkBox = document.getElementById("toggleswitch"); // ermöglicht das Wechseln der Spilefigur auch während der Pfad gezeichnet wird.
    if (checkBox.checked == true) {
        x = size*0.3;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            
            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+1.5*x,b+0.1*x)
            ctx.quadraticCurveTo(a+0.2*x, b+0.3*x, a+1.5*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+4*x,b+0.1*x)
            ctx.quadraticCurveTo(a+5.3*x, b+0.3*x, a+4*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.rect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            ctx.stroke();

            ax = a+1.7*x;
            bx = b+0.35*x;
            for (let i = 0; i < 3; i++) {
                shadow = 0.1*x
                ctx.beginPath();
                ctx.lineWidth = shadow;
                ctx.strokeStyle = "#DCdCdC";
                ctx.moveTo(ax, bx+shadow);
                ctx.lineTo(ax+2*x, bx+shadow);
                ctx.stroke();

                ctx.beginPath();
                ctx.lineWidth = 0.1*x;
                ctx.strokeStyle = "black";
                ctx.moveTo(ax, bx);
                ctx.lineTo(ax+2*x, bx);
                ctx.stroke();
                bx = bx + 0.4*x;
            }
        }
    } 
    else {
        x = size*0.25;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.fillRect(a+0, b+0.6*x, 1*x, 0.25*x);
            
            ax = a+2*x;
            bx = b+0;
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.lineWidth = x/20;
                ctx.strokeStyle = "black";

                ctx.moveTo(ax, bx);
                ctx.lineTo(ax, bx+0.8*x);
                ctx.stroke();
                ax = ax + 0.4*x;
            }
            
            ctx.beginPath();
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(a+1*x, b+0, 1*x, 1.5*x)

            ctx.beginPath();
            ctx.lineWidth = x/8;
            ctx.strokeStyle = "black";
            ctx.rect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.6*x, 1*x, 0.25*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.47*x, 0.05*x, 0.5*x);
            ctx.stroke();
            ctx.rect(a+5*x, b+0.7*x, 1.2*x, 0.01*x);
            ctx.stroke();
         } 
    }
}

var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");


const coordinates = [
    {a:2, b:1},
    {a:3, b:1},
    {a:6, b:2},
    {a:2, b:2},
    {a:4, b:2.5},
    {a:7, b:3},
    {a:1, b:3},
    {a:4, b:4.5},
    {a:1.5, b:4},
    {a:6.5, b:4},
    {a:2, b:5},
    {a:2.5, b:6},
    {a:6, b:5},
    {a:5.5, b:6},
    {a:0, b:1}, //Startpunkt hinzugefügt
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:2, b:7.5},
    {a:1, b:7.5},
    {a:3, b:7.5},
    {a:4, b:7.5},
    {a:5, b:7.5},
    {a:6, b:7.5},
    {a:7, b:7.5}
    ]



// Circle und Line habe ich hier in meinem Beispielfile definiert und Benutzt 

function circle(a,b){
    ctx.beginPath();
    ctx.arc(a,b, 3, 0, Math.PI*2);
    ctx.stroke();
}

function line(a,b,c,d) {
    ctx.beginPath();
    ctx.moveTo(a,b);
    ctx.lineTo(c,d);
    ctx.stroke();
} 

// Drawdown bewegt die Spielfigur auf die korrekte vertikale höhe und löst drawside aus

function drawdown(p1,p2,i,j){
    var a1 = (coordinates[p1].a)*size
    var a2 = (coordinates[p1].b)*size
    var b1 = (coordinates[p2].a)*size
    var b2 = (coordinates[p2].b)*size
    var a = a1; b = a2; c = a1; d = b2;            // Zuweisung Start und Endpunkte
    var disbd = d-b;                               // Abstände zwischen den Punkten
    var j = disbd*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var  movebd = disbd / j;                       //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    circle(a,b);
    if (i == j) {drawside(p1,p2,0)}
    else {
        var i = i + 1;
        const myTimeout = setTimeout(function() {
            line(a,b,a,b+(movebd*i));              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (movebd+j) verlängert
            vac(a,b+(movebd*i));
            drawdown(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
        }, 10);}
}

function drawside(p1,p2,i,j){
    var a1 = (coordinates[p1].a)*size
    var a2 = (coordinates[p1].b)*size
    var b1 = (coordinates[p2].a)*size
    var b2 = (coordinates[p2].b)*size
    var a = a1; b = b2; c = b1; d = b2;            // Zuweisung Start und Endpunkte
    var disac = Math.sqrt((c-a)**2);               // Abstände zwischen den Punkten, zuerst quadriert + dann wurzel damit wert positiv
    var j = disac*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var moveac = disac / j;                        //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    if (a > c) {                                   // a grösser als c: nach links gehen
        if (i == j) {circle(c,d)}
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a-(moveac*i),b);
                vac(a-(moveac*i),b);              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (moveac+j) verlängert
                drawside(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
            }, 10);}
    }
    else if (c > a) {                                 // c grösser als a: nach rechts gehen
        if (i == j) {circle(c,d)}
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a+(moveac*i),b),
                vac(a+(moveac*i),b);
                drawside(p1,p2,i,j)
            }, 10);}
    };
}

// Loadlines liest die bisherigen Punkte als Array ein und generiert eine Line die alle passierten Punkte auf einmal einblendet

function loadlines(knots){
    var start = [14,0];
    var knots = start.concat(knots);
    for (let i = 0; i < (knots.length)-2; i++) {
        var a1 = (coordinates[knots[i]].a)*size; a2 = (coordinates[knots[i]].b)*size; b1 = (coordinates[knots[i+1]].a)*size; b2 = (coordinates[knots[i+1]].b)*size;
        var a = a1; b = a2; c = a1; d = b2;        //start-/endpunkte vertikale linie
        circle(a,b);
        line(a,b,c,d);                             //vertikale linie
        var a = a1; b = b2; c = b1; d = b2;        //start-/endpunkte horizontale linie
        line(a,b,c,d);                             // horizontale linie
    }
}

//So habe ich die Funktionen getestet. Komischerweise funktioniert es aktuell nur wenn zuerst drawdown ausgeführt wird, 
//warum weiss ich nicht (Spielt von der funktionalität her aber keine rolle aktuell)

const games = [
    {userid:"001", username:"Martha", trackrecord:[1,2]},
    {userid:"002", username:"Theodor", trackrecord:[1,3,7]},
    {userid:"003", username:"Damiana", trackrecord:[1,3,4,8]},
    {userid:"004", username:"Noah", trackrecord:[]},
    {userid:"005", username:"Jo", trackrecord:[1]}
]

var game = games[2];

function initialise(game) {
    var path = game["trackrecord"]; var count = (path.length); var start = path[count-2]; var end = path[count-1];
    if (count == 0) {drawdown(14,0,0,0)}
    else if (count == 1) {loadlines(path); drawdown(0,end,0,0)}
    else {loadlines(path); drawdown(start,end,0,0)}
}

initialise(game)

</script>
