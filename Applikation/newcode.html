<!doctype html>
<html lang="de">
<head> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css"> <!-- Einbinden des CSS-Stylsheets -->
</head>
<body>
    <div class ="togglebox">
        <label class="toggle">
            <input id="toggleswitch" type="checkbox">
            <span class="roundbutton"></span>
         </label>
        <label class="toggletext">Wähle deine Spielfigur!</label class="toggletext">
    </div class ="togglebox">    
    <div class="anim">
        <canvas width="400" height="400" id="back" style="background-color: lightyellow ;position:absolute"></canvas>
        <canvas width="400" height="400" id="front" style="position:absolute"></canvas>
    </div class="anim">
</body>

<script>

const size = 50;
const corra = size*0.8; 
const corrb = size*0.2;

function clear(layer) {
    var canvas = document.getElementById(layer)
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,400,400);
        }
}

function vac(a,b) {
    var a = a - corra;
    var b = b - corrb;
    clear("front")
    var checkBox = document.getElementById("toggleswitch"); // ermöglicht das Wechseln der Spilefigur auch während der Pfad gezeichnet wird.
    if (checkBox.checked == true) {
        x = size*0.3;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            
            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+1.5*x,b+0.1*x)
            ctx.quadraticCurveTo(a+0.2*x, b+0.3*x, a+1.5*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.moveTo(a+4*x,b+0.1*x)
            ctx.quadraticCurveTo(a+5.3*x, b+0.3*x, a+4*x,b+1.5*x);
            ctx.stroke();

            ctx.beginPath();
            ctx.lineWidth = 0.1*x;
            ctx.strokeStyle = "black";
            ctx.rect(a+1.5*x,b+0.1*x, 2.5*x, 1.4*x);
            ctx.stroke();

            ax = a+1.7*x;
            bx = b+0.35*x;
            for (let i = 0; i < 3; i++) {
                shadow = 0.1*x
                ctx.beginPath();
                ctx.lineWidth = shadow;
                ctx.strokeStyle = "#DCdCdC";
                ctx.moveTo(ax, bx+shadow);
                ctx.lineTo(ax+2*x, bx+shadow);
                ctx.stroke();

                ctx.beginPath();
                ctx.lineWidth = 0.1*x;
                ctx.strokeStyle = "black";
                ctx.moveTo(ax, bx);
                ctx.lineTo(ax+2*x, bx);
                ctx.stroke();
                bx = bx + 0.4*x;
            }
        }
    } 
    else {
        x = size*0.25;
        var canvas = document.getElementById("front");
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.fillRect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.fillRect(a+0, b+0.6*x, 1*x, 0.25*x);
            
            ax = a+2*x;
            bx = b+0;
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.lineWidth = x/20;
                ctx.strokeStyle = "black";

                ctx.moveTo(ax, bx);
                ctx.lineTo(ax, bx+0.8*x);
                ctx.stroke();
                ax = ax + 0.4*x;
            }
            
            ctx.beginPath();
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(a+1*x, b+0, 1*x, 1.5*x)

            ctx.beginPath();
            ctx.lineWidth = x/8;
            ctx.strokeStyle = "black";
            ctx.rect(a+1*x, b+0, 4*x, 1.5*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.6*x, 1*x, 0.25*x);
            ctx.stroke();
            ctx.rect(a+0, b+0.47*x, 0.05*x, 0.5*x);
            ctx.stroke();
            ctx.rect(a+5*x, b+0.7*x, 1.2*x, 0.01*x);
            ctx.stroke();
         } 
    }
}

const coordinates = [
    {a:2, b:1},
    {a:3, b:1},
    {a:6, b:2},
    {a:2, b:2},
    {a:4, b:2.5},
    {a:7, b:3},
    {a:1, b:3},
    {a:4, b:4.5},
    {a:1.5, b:4},
    {a:6.5, b:4},
    {a:2, b:5},
    {a:2.5, b:6},
    {a:6, b:5},
    {a:5.5, b:6},
    {a:0, b:1}, //Startpunkt hinzugefügt
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:""},
    {a:2, b:7.5},
    {a:1, b:7.5},
    {a:3, b:7.5},
    {a:4, b:7.5},
    {a:5, b:7.5},
    {a:6, b:7.5},
    {a:7, b:7.5}
]

const linecolour = "grey";
const linewidth = 7;

function dot(a,b,dotsize,colour) {
    var canvas = document.getElementById("back");
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(a, b, dotsize, 0, Math.PI*2);
        ctx.fillStyle = colour;
        ctx.fill();
        ctx.closePath();
    }
}

function line(a,b,c,d) {
    var canvas = document.getElementById("back");
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');   
        dot(a,b,linewidth*0.5,linecolour);
        ctx.beginPath();
        ctx.moveTo(a,b);
        ctx.stroke();
        ctx.lineTo(c,d);
        ctx.lineWidth = linewidth;
        ctx.strokeStyle = linecolour;
        ctx.stroke();
        dot(a,b,linewidth*0.4,linecolour);
    }
} 

function maindots(a,b,type) {             //type 1: durchquerte dots; type 2: offene dots; type 3: zieldots
    if (type == 1) {dot(a,b,20,"#d0bdfb"); dot(a,b,10,"#808080")}
    else if (type == 2) { dot(a,b,20,"#d7966d"); dot(a,b,10,"#598ebb") }
    else if (type == 3) { dot(a,b,20,"#598ebb"); dot(a,b,10,"#d7966d") }
}


// Drawdown bewegt die Spielfigur auf die korrekte vertikale höhe und löst drawside aus

function drawdown(p1,p2,i,j){
    let c = coordinates; let s = size;
    var a1 = (c[p1].a)*s; a2 = (c[p1].b)*s; b1 = (c[p2].a)*s; b2 = (c[p2].b)*s;
    var a = a1; b = a2; c = a1; d = b2;            // Zuweisung Start und Endpunkte
    var disbd = d-b;                               // Abstände zwischen den Punkten
    var j = disbd*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var  movebd = disbd / j;                       //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    if (i == j) {drawside(p1,p2,0)}
    else {
        var i = i + 1;
        const myTimeout = setTimeout(function() {
            line(a,b,a,b+(movebd*i));              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (movebd+j) verlängert
            vac(a,b+(movebd*i));
            drawdown(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
        }, 10);}
}

//onspot-Intervall muss mit dem drücken des buttons gestoppt werden, nicht vergessen

function drawside(p1,p2,i,j){
    let c = coordinates; let s = size;
    var a1 = (c[p1].a)*s; a2 = (c[p1].b)*s; b1 = (c[p2].a)*s; b2 = (c[p2].b)*s;    var a = a1; b = b2; c = b1; d = b2;            // Zuweisung Start und Endpunkte
    var disac = Math.sqrt((c-a)**2);               // Abstände zwischen den Punkten, zuerst quadriert + dann wurzel damit wert positiv
    var j = disac*2;                               //j = Anzahl Aktualisierungen die nötig sind bei 2px/Aktualisierung
    var moveac = disac / j;                        //Abstand der Teilschritte damit bei verschiedenen Distanze gleichmässige Bewegung generiert wird
    if (a > c) {                                   // a grösser als c: nach links gehen
        if (i == j) { 
            dot(a1,a2,10,linecolour); {onspot = setInterval(function () {vac(b1,b2)}, 100)}}  //onspot interval aktualisiert die spielfigur im stillstand
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a-(moveac*i),b);
                vac(a-(moveac*i),b);              // bei jeder wiederholung wird die gleiche linie gezeichnet von a1,a2 aus aber sie wird um (moveac+j) verlängert
                drawside(p1,p2,i,j)                    //nach 10 millisekunden wird drawdown mit aktualisierte i neu gestartet
            }, 10);}
    }
    else if (c > a) {                                 // c grösser als a: nach rechts gehen
        if (i == j) {dot(a1,a2,10,linecolour); {onspot = setInterval(function () {vac(b1,b2)}, 100)}}  //onspot interval aktualisiert die spielfigur im stillstand
        else {
            var i = i + 1;
            const myTimeout = setTimeout(function() {
                line(a,b,a+(moveac*i),b),
                vac(a+(moveac*i),b);
                drawside(p1,p2,i,j)
            }, 10);}
    }
}

function dots() {  
    for (let i = 1; i < 14; i++) {
        let c = coordinates; let s = size;
        let a = (c[i].a)*s;let b = (c[i].b)*s;
        maindots(a,b,2);
    }
    for (let i = 21; i < 28; i++) {
        let c = coordinates; let s = size;
        let a = (c[i].a)*s;let b = (c[i].b)*s;
        maindots(a,b,3);
    }
}

// Loadlines liest die bisherigen Punkte als Array ein und generiert eine Line die alle passierten Punkte auf einmal einblendet

function loadlines(knots){
    var start = [14,0];
    var knots = start.concat(knots);
    for (let i = 0; i < (knots.length)-2; i++) {
        let c = coordinates; let k = knots; let s = size; 
        var a1 = (c[k[i]].a)*s; a2 = (c[k[i]].b)*s; b1 = (c[k[i+1]].a)*s; b2 = (c[k[i+1]].b)*s;
        var a = a1; b = a2; c = a1; d = b2;        //start-/endpunkte vertikale linie
        line(a,b,c,d);                             //vertikale linie
        var a = a1; b = b2; c = b1; d = b2;        //start-/endpunkte horizontale linie
        line(a,b,c,d);
        maindots(c,d,1);
    }

}

//So habe ich die Funktionen getestet. Komischerweise funktioniert es aktuell nur wenn zuerst drawdown ausgeführt wird, 
//warum weiss ich nicht (Spielt von der funktionalität her aber keine rolle aktuell)

const games = [
    {userid:"001", username:"Martha", trackrecord:[1,2]},
    {userid:"002", username:"Theodor", trackrecord:[1,3,7]},
    {userid:"003", username:"Damiana", trackrecord:[1,3,4,8]},
    {userid:"004", username:"Noah", trackrecord:[]},
    {userid:"005", username:"Jo", trackrecord:[1]}
]

var game = games[1];

function initialise(game) {
    dots();
    var path = game["trackrecord"]; var count = (path.length); var start = path[count-2]; var end = path[count-1];
    if (count == 0) {drawdown(14,0,0,0)}
    else if (count == 1) {loadlines(path); drawdown(0,end,0,0)}
    else {loadlines(path); drawdown(start,end,0,0)}
}

initialise(game)

</script>
